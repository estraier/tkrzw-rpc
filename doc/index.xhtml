<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta charset="UTF-8"/>
<title>Tkrzw-RPC: RPC interface of Tkrzw</title>
<link href="prism.css" rel="stylesheet"/>
<link href="tk-icon.png" rel="icon" type="image/png" sizes="144x144"/>
<style>/*<![CDATA[*/
html,body,article,p,pre,code,li,dt,dd,td,th,div { font-size: 12pt; }
html { margin: 0; padding: 0; background: #eeeeee; }
body { width: 100%; margin: 0; padding: 0; background: #eeeeee; text-align: center; }
body { animation: fadeIn 0.8s ease 0s 1 normal; -webkit-animation: fadeIn 0.8s ease 0s 1 normal; }
article { display: inline-block; max-width: 100ex; overflow: hidden; border: 1px solid #aaaaaa; border-radius: 2ex;
  margin: 2ex 1ex; padding: 3ex 3ex; background: #ffffff; text-align: left; line-height: 1.6; color: #111111; }
h1,h2,h3,h4,h5,h6 { color: #000000; margin: 2ex 0 0 0; text-indent: 0; }
h1 { text-align: center; margin: 2ex 0 3ex 0; }
p { text-indent: 2ex; }
pre { margin-left: 1.5ex; padding: 0.4ex 0.6ex; border: solid 1px #dddddd; border-radius: 0.5ex;
  white-space: pre-wrap; word-wrap: break-word; line-height: 1.2; text-indent: 0; font-size: 10pt; }
code { font-weight: bold; }
pre[class*="language-"] { font-size: 10pt; line-height: 120%; padding: 0.5ex 0.8ex; background: #f8f8f8;
  max-height: 70ex; }
pre.log { font-size: 9pt; line-height: 110%; padding: 0.5ex 0.8ex; background: #f8f8f8; }
li { margin-left: 0.2ex; }
dt { margin-left: 2.0ex; }
dd { margin-left: 5.0ex; }
table { margin-left: 1.5ex; border-collapse: collapse; }
td,th { padding: 0 0.5ex; border: 1px solid #dddddd; }
td { font-size: 11pt; }
td.num { text-align: right; }
th { font-size: 10pt; font-weight: normal; background: #eeeeee; }
a { color: #004488; }
div.logo { text-align: center; }
div.logo img { max-width: 30ex; }
div.dbstructure { text-align: center; }
div.dbstructure img { max-width: 70ex; }
div.chart { text-align: left; }
div.chart img { max-width: 80ex; }
h2 a.headanc, h3 a.headanc {
  display: none;
  font-size: 8pt;
  vertical-align: super;
  padding-left: 0.5ex;
}
h2:hover a.headanc, h3:hover a.headanc {
  display: inline;
  font-size: 10pt;
  vertical-align: super;
}
#toc_div { zoom: 85%; }
.toc_line_h2 { margin-left: 2ex; }
.toc_line_h3 { margin-left: 5ex; }
/*]]>*/</style>
<script type="text/javascript">/*<![CDATA[*/
function insert_toc() {
  let first_head = document.querySelector("h2, h3");
  let toc_div = document.createElement('div');
  toc_div.id = "toc_div";
  let toc_head = document.createElement('h2');
  toc_head.textContent = "Table of Contents";
  toc_head.id = "toc";
  toc_div.appendChild(toc_head);
  first_head.parentNode.insertBefore(toc_div, first_head);
  for (let header of document.querySelectorAll("h2, h3")) {
    if (header != toc_head) {
      let toc_line = document.createElement('div');
      toc_line.className = "toc_line_" + header.tagName;
      let toc_anchor = document.createElement('a');
      toc_anchor.href = "#" + header.id;
      toc_anchor.textContent = header.textContent
      toc_line.appendChild(toc_anchor);
      toc_div.appendChild(toc_line);
    }
    let anchor = document.createElement('a');
    anchor.textContent = "#"
    anchor.href = "#" + header.id;
    anchor.className = "headanc";
    header.appendChild(anchor);
  }
}
window.onload = function(){
  insert_toc();
}
/*]]>*/</script>
</head>
<body>
<script src="prism.js"/>
<article>

<h1 id="title">Tkrzw-RPC: RPC interface of Tkrzw</h1>

<h2 id="overview">Overview</h2>

<p>Tkrzw-RPC is a package of a server program which manages databases of Tkrzw and a library to access the service via gRPC protocol.  Tkrzw is a library to mange key-value storages in various algorithms.  With Tkrzw, the application can handle database files efficiently in process without any network overhead.  However, multiple processes cannot open the same database file simultaneously.  Tkrzw-RPC solves the issue by using a server program which manages database files and allowing other processes access the contents via RPC.</p>

<p>One server process can handle multiple databases, each of which can be different data structure and tuning parameters.  Each database is an instance of the <a href="https://dbmx.net/tkrzw/#polydbm_overview">PolyDBM</a> class, which is an adapter class to handle the following classes with the same interface.</p>

<ul>
<li><strong><a href="https://dbmx.net/tkrzw/#hashdbm_overview">HashDBM</a></strong> : File database manager implementation based on hash table.</li>
<li><strong><a href="https://dbmx.net/tkrzw/#treedbm_overview">TreeDBM</a></strong> : File database manager implementation based on B+ tree.</li>
<li><strong><a href="https://dbmx.net/tkrzw/#skipdbm_overview">SkipDBM</a></strong> : File database manager implementation based on skip list.</li>
<li><strong><a href="https://dbmx.net/tkrzw/#tinydbm_overview">TinyDBM</a></strong> : On-memory database manager implementation based on hash table.</li>
<li><strong><a href="https://dbmx.net/tkrzw/#babydbm_overview">BabyDBM</a></strong> : On-memory database manager implementation based on B+ tree.</li>
<li><strong><a href="https://dbmx.net/tkrzw/#cachedbm_overview">CacheDBM</a></strong> : On-memory database manager implementation with LRU deletion.</li>
</ul>

<p>The library of Tkrzw-RPC is a C++ library to access the database service via gRPC protocol.  Thus, you can easily write application programs in C++.  You use the class <a href="#remotedbm_overview">RemoteDBM</a> whose API is very similar to the PolyDBM class so that you can use it as if you operates local databases.  Moreover, gRPC automates to generate client interfaces in various languages, based on the service definition in the protocol buffers <a href="https://github.com/estraier/tkrzw-rpc/blob/master/tkrzw_rpc.proto">tkrzw_rpc.proto</a>.  Tkrzw-RPC also provides command line utilities to access the database service.</p>

<h2 id="download">Download</h2>

<p>You can download source packages in the following directories.</p>

<ul>
<li><a href="http://dbmx.net/tkrzw-rpc/pkg/">C++ source packages</a></li>
</ul>

<h2 id="api_documents">API Documents</h2>

<p>The following are API documents for each language.</p>

<ul>
<li><a href="http://dbmx.net/tkrzw-rpc/api/">C++ API documents</a></li>
</ul>

<h2 id="installation">Installation</h2>

<p>Tkrzw-RPC is implemented based on the C++17 standard and POSIX API.  It works on Unix-like systems (Linux, FreeBSD, and Mac OS X), and GCC (version 7.3 or later) is required to build programs.</p>

<p>Download the latest version of the source packages.  The core library of <a href="https://grpc.io/">gRPC</a> is also required so install it beforehand.</p>

<p>To build the server and the library, usually, you will run the following commands.  If you have installed Tkrzw and gRPC into another location than "/usr/local", specify the prefix by the "--with-extra" of "./configure", such as "--with-extra=/opt/homebrew".</p>

<pre><code class="language-shell-session"><![CDATA[$ ./configure --enable-opt-native
$ make
$ sudo make install
]]></code></pre>

<p>By default, the library and related files are installed under "/usr/local".  If you want to install the files under "/usr", specify "--prefix=/usr" with the configure scriptt.</p>

<pre><code class="language-shell-session"><![CDATA[/usr/local/lib/libtkrzw.a
/usr/local/lib/libtkrzw.so
/usr/local/lib/libtkrzw_rpc.a
/usr/local/include/tkrzw_dbm_remote.h
/usr/local/share/tkrzw/tkrzw_rpc.proto
/usr/local/bin/tkrzw_rpc_build_util
/usr/local/bin/tkrzw_server
/usr/local/bin/tkrzw_dbm_remote_util
/usr/local/bin/tkrzw_dbm_remote_perf
]]></code></pre>

<p>To run the test suite, GoogleTest is required.  Although testing the library is not necessary for most users, you can do so just in case.</p>

<pre><code class="language-shell-session"><![CDATA[$ make test
$ make testrun
]]></code></pre>

<p>You can run end-to-end tests with the following procedures.  First, run the server.</p>

<pre><code class="language-shell-session"><![CDATA[$ tkrzw_server --log_level debug
]]></code></pre>

<p>While the server is running, run the client commands on another terminal.</p>

<pre><code class="language-shell-session"><![CDATA[$ make check
]]></code></pre>

<p>If the "Checking completed" is shown, all checks are OK.  You can stop the server process by inputting Ctrl-C on the same terminal.</p>

<h2 id="tutorial">Tutorial</h2>

<p>Let's run the server with a simple setting.  By default, an on-memory database of TinyDBM is specified.  By specifying the log level to "debug", every RPC call to the service is printed in the log stream.</p>

<pre><code class="language-shell-session"><![CDATA[$ tkrzw_server --log_level debug
]]></code></pre>

<p>Let's play with the command line utilities on another terminal.</p>

<pre><code class="language-shell-session"><![CDATA[# Stores three records
$ tkrzw_dbm_remote_util set one first
$ tkrzw_dbm_remote_util set two second
$ tkrzw_dbm_remote_util set three third

# Retrieves each record
$ tkrzw_dbm_remote_util get one
first
$ tkrzw_dbm_remote_util get two
second
$ tkrzw_dbm_remote_util get three
third

# Removes one record
$ tkrzw_dbm_remote_util remove one

# Lists all records
$ tkrzw_dbm_remote_util list
three    third
two      second
]]></code></pre>

<p>Stop the server by inputting Ctrl-C on the terminal of the server command.  Such logs as the following are printed.</p>

<pre class="log"><![CDATA[2021/08/30 21:44:55 [INFO] ==== Starting the process as a command ====
2021/08/30 21:44:55 [INFO] Version: rpc_pkg=0.5.0, rpc_lib=1.1.0, core_pkg=1.0.6, core_lib=1.49.0
2021/08/30 21:44:55 [INFO] Opening a database: #dbm=tiny
2021/08/30 21:44:55 [INFO] Server: address=0.0.0.0:1978, pid=1175899
2021/08/30 21:45:20 [DEBUG] 127.0.0.1:59208 [Set] key: "one" value: "first" overwrite: true
2021/08/30 21:45:24 [DEBUG] 127.0.0.1:59210 [Set] key: "two" value: "second" overwrite: true
2021/08/30 21:45:29 [DEBUG] 127.0.0.1:59212 [Set] key: "three" value: "third" overwrite: true
2021/08/30 21:45:38 [DEBUG] 127.0.0.1:59214 [Get] key: "one"
2021/08/30 21:45:48 [DEBUG] 127.0.0.1:59216 [Get] key: "two"
2021/08/30 21:46:01 [DEBUG] 127.0.0.1:59218 [Get] key: "three"
2021/08/30 21:46:11 [DEBUG] 127.0.0.1:59220 [Remove] key: "one"
2021/08/30 21:46:21 [DEBUG] 127.0.0.1:59224 [Iterate] operation: OP_FIRST
2021/08/30 21:46:21 [DEBUG] 127.0.0.1:59224 [Iterate] operation: OP_GET
2021/08/30 21:46:21 [DEBUG] 127.0.0.1:59224 [Iterate] operation: OP_NEXT
2021/08/30 21:46:21 [DEBUG] 127.0.0.1:59224 [Iterate] operation: OP_GET
2021/08/30 21:46:21 [DEBUG] 127.0.0.1:59224 [Iterate] operation: OP_NEXT
2021/08/30 21:46:21 [DEBUG] 127.0.0.1:59224 [Iterate] operation: OP_GET
2021/08/30 21:48:53 [INFO] Shutting down by signal: 2
2021/08/30 21:48:53 [INFO] The server finished
2021/08/30 21:48:53 [INFO] Closing a database
2021/08/30 21:48:53 [INFO] ==== Ending the process in success ====
]]></pre>

<p>As the on-memory database was not associated with any file, records in the database vanished whn the server shut down.  Next, let's run the server with two on-memory databases associated with files.  The first database is TinyDBM, which is on-memory hash database.  The second database is BabyDBM, which is on-memory tree database.</p>

<pre><code class="language-shell-session"><![CDATA[$ tkrzw_server --log_level debug "casket-1.tkmt" "casket-2.tkmb"
]]></code></pre>

<p>Let's add serveral records to each databases.  The target of the operation is specified by the "--index" option, whose default value is zero referring to the first database.</p>

<pre><code class="language-shell-session"><![CDATA[$ tkrzw_dbm_remote_util set one first
$ tkrzw_dbm_remote_util set two second
$ tkrzw_dbm_remote_util set three third

$ tkrzw_dbm_remote_util set --index 1 japan tokyo
$ tkrzw_dbm_remote_util set --index 1 china beijing
$ tkrzw_dbm_remote_util set --index 1 korea seoul
]]></code></pre>

<p>Stop the server by inputting Ctrl-C on the terminal of the server command.  This time, all records are stored in the specified files.  Then, restart the server with the same arguemnts.</p>

<pre><code class="language-shell-session"><![CDATA[$ tkrzw_server --log_level debug "casket-1.tkmt" "casket-2.tkmb"
]]></code></pre>

<p>Confirm that the records are loaded properly.  As the second database is an ordered database, the record keys are in acsending order for sure.</p>

<pre><code class="language-shell-session"><![CDATA[$ tkrzw_dbm_remote_util list
three	 third
two	   second
one	   first

$ tkrzw_dbm_remote_util list --index 1
china  beijing
japan  tokyo
korea  seoul
]]></code></pre>

<p>Read <a href="https://dbmx.net/tkrzw/api-rpc/">the C++ API documents</a> for usage of the C++ client library.  Then, let's build a sample program.  Make a file of the following C++ code and save it as "helloworld.cc".</p>

<pre><code class="language-shell-session"><![CDATA[#include "tkrzw_dbm_remote.h"

int main(int argc, char** argv) {
  tkrzw::RemoteDBM dbm;
  dbm.Connect("localhost", 1978).OrDie();
  dbm.Set("hello", "world").OrDie();
  std::cout << dbm.GetSimple("hello") << std::endl;
  dbm.Disconnect().OrDie();
  return 0;
}
]]></code></pre>

<p>To build an application program, you'll typically run a command like this.  The compiler flag "-std=c++17" is necessary if the default C++ version of your compiler is older than C++17.</p>

<pre><code class="language-shell-session"><![CDATA[$ g++ -std=c++17 -pthread -I/usr/local/include \
  -O2 -Wall helloworld.cc -o helloworld \
  -L/usr/local/lib -ltkrzw_rpc -lgrpc++_reflection -lgrpc++ -lgrpc -lprotobuf \
  -ltkrzw -lstdc++ -lpthread
]]></code></pre>

<p>The bundled command "tkrzw_rpc_build_util" is useful to know necessary CPPFLAGS (flags for the preprocessor), and LDFLAGS (flags for the linker).</p>

<pre><code class="language-shell-session"><![CDATA[$ tkrzw_rpc_build_util config -i
-I/usr/local/include
$ tkrzw_rpc_build_util config -l
-L/usr/local/lib -ltkrzw_rpc -lgrpc++_reflection -lgrpc++ -lgrpc -lprotobuf -ltkrzw -lstdc++ -lpthread -lm -lc
]]></code></pre>

<p>In some environments, you can also use the "pkg-config" command to list up those flags.</p>

<pre><code class="language-shell-session"><![CDATA[$ export PKG_CONFIG_PATH="/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH"
$ pkg-config --cflags-only-I tkrzw-rpc
-I/usr/local/include
$ pkg-config --libs tkrzw-rpc
-L/usr/local/lib -ltkrzw_rpc -lgrpc++_reflection -lgrpc++ -lgrpc -lprotobuf -ltkrzw -lstdc++ -lpthread -lm -lc
]]></code></pre>

<p>Build the above sample program and run it while the server is running.</p>

<pre><code class="language-shell-session"><![CDATA[$ ./helloworld
world
]]></code></pre>

<h2 id="commands">Commands Line Interfaces</h2>

<h3 id="commands_tkrzw_rpc_build_util">tkrzw_rpc_build_util: Build Utilities</h3>

<p>tkrzw_rpc_build_util is a command for build utilities.  Thereby, you can obtain flags to build your own program using the library of Tkrzw-RPC.  The usage is the following.  A subcommand name comes as the first argument.  Some options and other arguments can follow.</p>

<dl>
<dt><code>tkrzw_rpc_build_util config [<var>options</var>]</code></dt>
<dd>Prints configurations.</dd>
<dt><code>tkrzw_rpc_build_util version</code></dt>
<dd>Prints the version information.</dd>
</dl>

<dl>
<dt>Options of the config subcommand:</dt>
<dd><code>-v</code> : Prints the version number.</dd>
<dd><code>-i</code> : Prints C++ preprocessor options for build.</dd>
<dd><code>-l</code> : Prints linker options for build.</dd>
<dd><code>-p</code> : Prints the prefix for installation.</dd>
</dl>

<p>The following is a way to build your own application without setting complicated flags.</p>

<pre><code class="language-shell-session"><![CDATA[$ g++ -std=c++17 -pthread \
  $(tkrzw_rpc_build_util config -i) \
  -O2 -Wall helloworld.cc -o helloworld \
  $(tkrzw_rpc_build_util config -l)
]]></code></pre>

<h3 id="commands_tkrzw_server">tkrzw_server: Database Server</h3>

<p>tkrzw_server is a command to run the database service of Tkrzw-RPC.  One server process can handle multiple databases at the same time.  The process can be a daemon process to run in the background.  The server can use either of IPv4, IPv6, or UNIX domain socket as the network interface.</p>

<dl>
<dt><code>tkrzw_server [<var>options</var>] [<var>db_configs</var>]</code></dt>
<dd>Runs the database service.</dd>
</dl>

<dl>
<dt>Options:</dt>
<dd><code>--version</code> : Prints the version number and exit.</dd>
<dd><code>--address <var>str</var></code> : The address/hostname and the port of the server (default: 0.0.0.0:1978)</dd>
<dd><code>--log_file <var>str</var></code> : The file path of the log file. (default: /dev/stdout)</dd>
<dd><code>--log_level <var>str</var></code> : The minimum log level to be stored: debug, info, warn, error, fatal. (default: info)</dd>
<dd><code>--log_date <var>str</var></code> : The log date format: simple, simple_micro, w3cdtf, w3cdtf_micro, rfc1123, epoch, epoch_micro. (default: simple)</dd>
<dd><code>--log_td <var>num</var></code> : The log time difference in seconds. (default: 99999=local)</dd>
<dd><code>--pid_file <var>str</var></code> : The file path of the store the process ID.</dd>
<dd><code>--daemon</code> : Runs the process as a daemon process.</dd>
<dd><code>--read_only</code> : Opens the databases in the read-only mode.</dd>
</dl>

<p>If you don't set database configurations, an on-memory database of TinyDBM with the default tuning is served.  You can set one or more database configurations too.  Each confituration is in the format of "path#name1=value1,name2=value2,..." which is composed of the file path of the database, "#", and CSV of tuning parameters.  The extension of the database path determines the database class.  ".tkh" for HashDBM, ".tkt" for TreeDBM, ".tks" for SkipDBM, ".tkmt" for TinyDBM, ".tkmb" for BabyDBM, and ".tkmc" for CacheDBM.  The database path can be empty for on-memory databases.  The "dbm" parameter overwrites the decision by the extension.  The following are samples.  See <a href="https://dbmx.net/tkrzw/#polydbm_overview">PolyDBM</a> for details.</p>

<dl>
<dt>#dbm=BabyDBM</dt>
<dd>Opens a BabyDBM without associating any file.</dd>
<dt>casket#dbm=HashDBM</dt>
<dd>Opens the file "casket" as a HashDBM.</dd>
<dt>casket.tkh#num_buckets=10M,update_mode=appending,restore_mode=sync</dt>
<dd>Opens the file "casket.tkh" as a HashDBM.  The bucket number is set to 10 million.  Uses the appending update mode and the synchronous restore mode.</dd>
<dt>casket.tkh#num_buckets=100M,align_pow=8,cache_buckets=1,file=pos-para,block_size=512,access_options=direct:padding:pagecache</dt>
<dd>Opens the file "casket.tkh" as a HashDBM.  The bucket number is set to 100 million.  The other parameters are tuned for direct I/O.</dd>
<dt>casket.tkt#num_buckets=1M,max_cached_pages=100K</dt>
<dd>Opens the file "casket.tkt" as a TreeDBM.  The bucket number is set to 1 million.  The maximum number of cached pages is 100 thousand.</dd>
<dt>casket.tks#sort_mem_size=2Gi,max_cached_records=100K</dt>
<dd>Opens the file "casket.tkt" as a TreeDBM.  The memory size for sorting is 2GiB.  The maximum number of cached records is 100 thousand.</dd>
<dt>casket.tkmt#num_buckets=10M</dt>
<dd>Opens the file "casket.tkmt" as a TinyDBM.  The bucket number is set to 10 million.</dd>
<dt>casket.tkmb</dt>
<dd>Opens the file "casket.tkmb" as a BabyDBM.</dd>
<dt>casket.tkmc#cap_rec_num=10M,cap_mem_size=2Gi</dt>
<dd>Opens the file "casket.tkmc" as a CacheDBM.  The maximum number of records is 10 million.  The total memory size to use is 2GiB.</dd>
</dl>

<p>By default, the server address is "0.0.0.0:1978", which means that the socket is bound to all network interfaces of IPv4 and IPv6 on the machine and that the port number is 1978.  To use a UNIX domain socket, specify the socket file path like "unix:/run/tkrzw_server.socket".</p>

<p>To finish the server process running on foreground, input Ctrl-C on the terminal.  If you run the server as a system service, run the process as a daemon with the "--daemon" flag.  To finish the daemon process, send a termination signal such as SIGTERM by the "kill" command.  If a daemon process catches SIGHUP, the log file is re-opened.  To send signals to the process, you have to know the process ID.  So, it's a good practice to write the process ID to a file by the "--pid" flag.  Because thr current directory of a daemon process is changed to the root directory, paths of related files should be described as their absolute paths.</p>

<p>The following command starts the database service as a daemon process.  Usually, it is run by the start up script of the system.</p>

<pre><code class="language-shell-session"><![CDATA[tkrzw_server --address 0.0.0.0:1978 --daemon \
  --log_file /var/log/tkrzw_server.log \
  --pid_file /run/tkrzw_server.pid \
  "/var/db/casket-1.tkh#num_buckets=10M"
]]></code></pre>

<p>The following command stops the database service gracefully.  Usually, it is run by the the shutdown script of the system.</p>

<pre><code class="language-shell-session"><![CDATA[if test -f /run/tkrzw_server.pid
then
  kill -TERM `cat /run/tkrzw_server.pid`
fi
]]></code></pre>

<p>For log rotation, you run the following script.  Usually, it is run by a cron script invoked periodically.</p>

<pre><code class="language-shell-session"><![CDATA[mv /var/log/tkrzw_server.log /var/log/tkrzw_server.log.`date "+%Y%m%d%H%M%S"`
if test -f /run/tkrzw_server.pid
then
  kill -HUP `cat /run/tkrzw_server.pid`
fi
]]></code></pre>

<h3 id="commands_tkrzw_dbm_remote_util">tkrzw_dbm_remote_util: Database Client</h3>

<p>tkrzw_dbm_remote_util is a client command to invoke RPCs.  Thereby, you can set records, retrieve records, remove records, and rebuild databases.  A subcommand name comes as the first argument.  Some options and other arguments can follow.</p>

<dl>
<dt><code>tkrzw_dbm_remote_util echo [<var>options</var>] [<var>message</var>]</code></dt>
<dd>Invokes an echoing back test.</dd>
<dt><code>tkrzw_dbm_remote_util inspect [<var>options</var>] [<var>attr</var>]</code></dt>
<dd>Prints inspection of a database file.</dd>
<dt><code>tkrzw_dbm_remote_util get [<var>options</var>] <var>key</var></code></dt>
<dd>Gets a record and prints it.</dd>
<dt><code>tkrzw_dbm_remote_util set [<var>options</var>] <var>key</var> <var>value</var></code></dt>
<dd>Sets a record.</dd>
<dt><code>tkrzw_dbm_remote_util remove [<var>options</var>] <var>key</var></code></dt>
<dd>Removes a record.</dd>
<dt><code>tkrzw_dbm_remote_util list [<var>options</var>]</code></dt>
<dd>Lists up records and prints them.</dd>
<dt><code>tkrzw_dbm_remote_util clear [<var>options</var>]</code></dt>
<dd>Removes all records.</dd>
<dt><code>tkrzw_dbm_remote_util rebuild [<var>options</var>] [<var>params</var>]</code></dt>
<dd>Rebuilds a database file for optimization.</dd>
<dt><code>tkrzw_dbm_remote_util sync [<var>options</var>] [<var>params</var>]</code></dt>
<dd>Synchronizes a database file.</dd>
</dl>

<dl>
<dt>Common options:</dt>
<dd><code>--version</code> : Prints the version number and exits.</dd>
<dd><code>--address</code> : The address and the port of the service (default: localhost:1978)</dd>
<dd><code>--timeout</code> : The timeout in seconds for connection and each operation.</dd>
<dd><code>--index</code> : The index of the DBM to access. (default: 0)</dd>
</dl>

<dl>
<dt>Options for the set subcommand:</dt>
<dd><code>--no_overwrite</code> : Fails if there's an existing record wit the same key.</dd>
<dd><code>--append <var>str</var></code> : Appends the value at the end after the given delimiter.</dd>
<dd><code>--incr <var>num</var></code> : Increments the value with the given initial value.</dd>
</dl>

<dl>
<dt>Options for the list subcommand:</dt>
<dd><code>--move <var>type</var></code> : Type of movement: first, jump, jumplower, jumplowerinc, jumpupper, jumpupperinc. (default: first)</dd>
<dd><code>--jump_key <var>str</var></code> : Specifies the jump key. (default: empty string)</dd>
<dd><code>--items <var>num</var></code> : The number of items to print.</dd>
<dd><code>--escape</code> : C-style escape is applied to the TSV data.</dd>
</dl>

<dl>
<dt>Options for the sync subcommand:</dt>
<dd><code>--hard</code> : Does physical synchronization with the hardware.</dd>
</dl>

<p>The following is a sample usage to make a remove database to associate country names to their capital cities' names.  If the extension of the file is "tkh", the type of the database is regarded as HashDBM.</p>

<pre><code class="language-shell-session"><![CDATA[$ tkrzw_dbm_remote_util clear
$ tkrzw_dbm_remote_util set Japan Tokyo
$ tkrzw_dbm_remote_util set Korea Seoul
$ tkrzw_dbm_remote_util set China Beijing
$ tkrzw_dbm_remote_util get Japan
Tokyo
$ tkrzw_dbm_remote_util remove Japan
$ tkrzw_dbm_remote_util rebuild "num_buckets=100"
$ tkrzw_dbm_remote_util sync --hard
$ tkrzw_dbm_remote_util list
China  Beijing
Korea  Seoul
]]></code></pre>

<p>To make a backup file of a database while the server is running, you can use the "sync" subcommand and set the "make_backup" parameter true.  A prefix like ".backup.20210901233046" is added to the database file name to generage the backup file name.</p>

<pre><code class="language-shell-session"><![CDATA[$ tkrzw_dbm_remote_util sync "make_backup=true"
]]></code></pre>

<h3 id="commands_tkrzw_dbm_remote_perf">tkrzw_dbm_remote_perf: Performance Checker</h3>

<p>tkrzw_dbm_remote_perf is a command for checking performance of RPC invodation.  Thereby, you can check performance of remote database operations in various scenarios including multithreading.  A subcommand name comes as the first argument.  Some options and other arguments can follow.</p>

<dl>
<dt><code>tkrzw_dbm_remote_perf sequence [<var>options</var>]</code></dt>
<dd>Checks echoing/setting/getting/removing performance in sequence.</dd>
<dt><code>tkrzw_dbm_remote_perf wicked [<var>options</var>]</code></dt>
<dd>Checks consistency with various operations.</dd>
</dl>

<dl>
<dt>Common options:</dt>
<dd><code>--address</code> : The address and the port of the service (default: localhost:1978)</dd>
<dd><code>--timeout</code> : The timeout in seconds for connection and each operation.</dd>
<dd><code>--index</code> : The index of the DBM to access. (default: 0)</dd>
<dd><code>--iter <var>num</var></code> : The number of iterations. (default: 10000)</dd>
<dd><code>--size <var>num</var></code> : The size of each record value. (default: 8)</dd>
<dd><code>--threads <var>num</var></code> : The number of threads. (default: 1)</dd>
<dd><code>--separate</code> : Use separate instances for each thread.</dd>
<dd><code>--random_seed <var>num</var></code> : The random seed or negative for real RNG. (default: 0)</dd>
</dl>

<dl>
<dt>Options for the sequence subcommand:</dt>
<dd><code>--random_key</code> : Uses random keys rather than sequential ones.</dd>
<dd><code>--random_value</code> : Uses random length values rather than fixed ones.</dd>
<dd><code>--echo_only</code> : Does only echoing.</dd>
<dd><code>--set_only</code> : Does only setting.</dd>
<dd><code>--get_only</code> : Does only getting.</dd>
<dd><code>--iter_only</code> : Does only iterating.</dd>
<dd><code>--remove_only</code> : Does only removing.</dd>
</dl>

<p>The following is a sample usage to echo back 1 million messages, to store 1 million records of 8-byte keys and 8-byte values, to retrieve all of them, and to remove all of them in sequence.  The number of threads is 10 and each thread does 100 thousand operations.</p>

<pre><code class="language-shell-session"><![CDATA[$ tkrzw_dbm_remote_perf sequence --iter 100k --threads 10
]]></code></pre>

<h2 id="remotedbm_overview">RemoteDBM: The Remote Database</h2>

<p>The remote database is an interface to access the database service of Tkrzw-RPC.  It encapsulates the existence of the network layer so that you can use the features as if you operate local databases.  RemoteDBM is thread-safe so multiple threads can share the same instance, which saves the number of connections.</p>

<p>Before any operation, you have to call the Connect method to make a connection to the database server.  You set the server address and the port number, like "192.168.0.8:1978" and "example.com:8080".  To use a UNIX domain socket, set the path like "unix:/run/tkrzw_server.socket".  You can disconnect the connection by calling the Disconnect method.</p>

<p>The database service can handle multiple databases at the same time.  By default, the target database of operation by a RemoteDBM instance is the first database of the service.  If you access the second database, call the SetDBMIndex method with the parameter 1.  If you access the third database, set the parameter 2.  If multiple threads uses different indices, they should use separate instances of RemoteDBM.</p>

<p>To retrieve, store, and remove a record, you call the Get, Set, and Remove methods respectively.  If you handle multiple records at once, calling the GetMulti, SetMulti, and RemoveMulti methods is better in terms of performance.  CompareExchange, CompareExchangeMulti, and Increment are useful methods to do atomic operations.</p>

<p>Most methods return a Status object to represent the result of the operation.  The meaning of the status code is the same as the local API except for the code NETWORK_ERROR which represents errors from gRPC.</p>

<h3 id="hashdbm_example">Example Code</h3>

<p>This is a code example where basic operations are done without checking errors.</p>

<pre><code class="language-cpp"><![CDATA[#include "tkrzw_dbm_remote.h"

// Main routine.
int main(int argc, char** argv) {
  // All symbols of Tkrzw are under the namespace "tkrzw".
  using namespace tkrzw;

  // Creates the database manager.
  RemoteDBM dbm;

  // Connects to the database service.
  dbm.Connect("localhost:1978");
  
  // Stores records.
  dbm.Set("foo", "hop");
  dbm.Set("bar", "step");
  dbm.Set("baz", "jump");

  // Retrieves records.
  std::cout << dbm.GetSimple("foo", "*") << std::endl;
  std::cout << dbm.GetSimple("bar", "*") << std::endl;
  std::cout << dbm.GetSimple("baz", "*") << std::endl;
  std::cout << dbm.GetSimple("outlier", "*") << std::endl;

  // Traverses records.
  std::unique_ptr<RemoteDBM::Iterator> iter = dbm.MakeIterator();
  iter->First();
  std::string key, value;
  while (iter->Get(&key, &value) == Status::SUCCESS) {
    std::cout << key << ":" << value << std::endl;
    iter->Next();
  }
  
  // Disconnects the connection.
  dbm.Disconnect();

  return 0;
}
]]></code></pre>

<p>This is a code example which represents a more serious use case with thorough error checks.</p>

<pre><code class="language-cpp"><![CDATA[#include "tkrzw_cmd_util.h"
#include "tkrzw_dbm_remote.h"

// Main routine.
int main(int argc, char** argv) {
  // All symbols of Tkrzw are under the namespace "tkrzw".
  using namespace tkrzw;

  // Creates the database manager.
  RemoteDBM dbm;

  // Connects to the database service.
  // The timeout is set to 1.5 seconds.
  Status status = dbm.Connect("localhost:1978", 1.5);
  if (status != Status::SUCCESS) {
    // Failure of the Connect operation is critical so we stop.
    Die("Connect failed: ", status);
  }

  // Stores records.
  // Bit-or assignment to the status updates the status if the original
  // state is SUCCESS and the new state is an error.
  status |= dbm.Set("foo", "hop");
  status |= dbm.Set("bar", "step");
  status |= dbm.Set("baz", "jump");
  if (status != Status::SUCCESS) {
    // The Set operation shouldn't fail.  So we stop if it happens.
    Die("Set failed: ", status);
  }

  // Retrieves records.
  // If there was no record, NOT_FOUND_ERROR would be returned.
  std::string value;
  status = dbm.Get("foo", &value);
  if (status == Status::SUCCESS) {
    std::cout << value << std::endl;
  } else {
    std::cerr << "missing: " << status << std::endl;
  }

  // Traverses records.
  std::unique_ptr<RemoteDBM::Iterator> iter = dbm.MakeIterator();
  if (iter->First() != Status::SUCCESS) {
    // Failure of the First operation is critical so we stop.
    Die("First failed: ", status);
  }
  while (true) {
    // Retrieves the current record data.
    std::string iter_key, iter_value;
    status = iter->Get(&iter_key, &iter_value);
    if (status == Status::SUCCESS) {
      std::cout << iter_key << ":" << iter_value << std::endl;
    } else {
      // This happens at the end of iteration.
      if (status != Status::NOT_FOUND_ERROR) {
        // Error types other than NOT_FOUND_ERROR are critical.
        Die("Iterator::Get failed: ", status);
      }
      break;
    }
    // Moves the iterator to the next record.
    status = iter->Next();
    if (status != Status::SUCCESS) {
      // This could happen if another thread removed the current record.
      if (status != Status::NOT_FOUND_ERROR) {
        // Error types other than NOT_FOUND_ERROR are critical.
        Die("Iterator::Get failed: ", status);
      }
      std::cerr << "missing: " << status << std::endl;
      break;
    }
  }
  
  // Disconnects the connection.
  // Even if you forgot to disconnect it, the destructor would do it.
  // However, checking the status is a good manner.
  status = dbm.Disconnect();
  if (status != Status::SUCCESS) {
    // The Disconnect operation shouldn't fail.  So we stop if it happens.
    Die("Disconnect failed: ", status);
  }

  return 0;
}
]]></code></pre>

<h2 id="license">License</h2>

<p>Tkrzw-RPC is written mainly by Mikio Hirabayashi, copyrighted by Google LLC, and distributed under the Apache license 2.0.  See the COPYING file in the package for detail.</p>

</article>
</body>
</html>
